{{#> layout}}
  {{#*inline "pageContent"}}
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels"></script>
    <link href="/css/test.css" rel="stylesheet">

    <h2>Іспит</h2>

    <!-- Pagination -->
    <div class="pagination">
    {{#each test.items as |item index|}}
      {{#if (eq (mod index 25) 0)}}
        <div class="pagination-row">
      {{/if}}
        <button
          class="pagination-button
            {{#if (eq ../currentQuestionIndex index )}}current
            {{else}}{{#if (eq item.user_answer item.question.q_correct_answer)}}correct
            {{else}}{{#if
            (and (neq item.user_answer null) (neq item.user_answer item.question.q_correct_answer))}}incorrect{{/if}}{{/if}}{{/if}}"
          onclick="navigateToQuestion({{../test.test_id}}, {{index}})">
          <span class="pagination-text">{{add index 1}}</span>
        </button>
      {{#if (eq (mod (add index 1) 25) 0)}}
        </div>
      {{/if}}
    {{/each}}
    {{#if (neq (mod test.items.length 25) 0)}}
      </div>
    {{/if}}
    </div>

    <!-- Question Block -->
    <div class="question-block">
      <div class="question-content">
        <h6>{{add 1 currentQuestionIndex}} запитання з теми {{current_theme}}</h6>
        <h5>{{currentQuestion.question.q_content}}</h5>
      </div>
      {{#if currentQuestion.question.q_image}}
        <div class="question-image">
          <img src="data:image/png;base64,{{hexToBase64 currentQuestion.question.q_image}}" alt="Question Image">
        </div>
      {{/if}}
      <div class="question-answers">
        {{#if currentQuestion.question.q_answer1}}
          <button class="answer-button" data-answer="1">{{currentQuestion.question.q_answer1}}</button>
        {{/if}}
        {{#if currentQuestion.question.q_answer2}}
          <button class="answer-button" data-answer="2">{{currentQuestion.question.q_answer2}}</button>
        {{/if}}
        {{#if currentQuestion.question.q_answer3}}
          <button class="answer-button" data-answer="3">{{currentQuestion.question.q_answer3}}</button>
        {{/if}}
        {{#if currentQuestion.question.q_answer4}}
          <button class="answer-button" data-answer="4">{{currentQuestion.question.q_answer4}}</button>
        {{/if}}
        {{#if currentQuestion.question.q_answer5}}
          <button class="answer-button" data-answer="5">{{currentQuestion.question.q_answer5}}</button>
        {{/if}}


        <!-- End Test Button -->
        <button class="btn btn-success end-test-button" {{#if test.is_done}} onclick="endTest({{test.test_id}}, 'Результати', false, this)">
          Показати результати {{else}} onclick="endTest({{test.test_id}}, 'Тест завершено!', true, this)"> Закінчити тест{{/if}}</button>
      </div>
    </div>


    <!-- End Test Modal -->
    <div id="endTestModal" class="modal">
      <div class="modal-content">
        <span class="close" onclick="closeModal()">&times;</span>
        <h6 id="resultsTitle"></h6>
        <p>Запитань пройдено: <span id="answeredQuestions"></span></span></p>
        <div class="chartCard">
          <div class="chartBox">
            <canvas id="resultChart"></canvas>
          </div>
        </div>
        <button class="btn btn-success" onclick="window.location.href = `/tests/exam`">Ще один іспит!</button>
      </div>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const userAnswer = '{{currentQuestion.user_answer}}';
        const correctAnswer = '{{currentQuestion.question.q_correct_answer}}';

        // Highlight the answers based on previous selection
        if (userAnswer) {
          document.querySelectorAll('.answer-button').forEach((btn) => {
            const answer = btn.getAttribute('data-answer');
            if (answer === correctAnswer) {
              btn.classList.add('correct');
            } else if (answer === userAnswer) {
              btn.classList.add('incorrect');
            }
            btn.disabled = true;
          });
        }

        // Add event listeners to answer buttons
        document.querySelectorAll('.answer-button').forEach((button) => {
          if ({{test.is_done}}) {
            button.disabled = true;
            return;
          }

          button.addEventListener('click', async function() {
            const userAnswer = this.getAttribute('data-answer');
            const questionId = '{{currentQuestion.test_question_id}}';
            try {
              const response = await fetch(`/tests/update/questions/${questionId}`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'X-Requested-With': 'XMLHttpRequest',
                },
                body: JSON.stringify({ user_answer: userAnswer }),
              });

              if (!response.ok) {
                throw new Error('Network response was not ok');
              }

              const result = await response.json();

              // Highlight the buttons based on the correctness of the answer
              document.querySelectorAll('.answer-button').forEach((btn) => {
                const answer = btn.getAttribute('data-answer');
                btn.classList.remove('correct', 'incorrect');
                if (answer == result.correctAnswer) {
                  btn.classList.add('correct');
                } else if (answer == userAnswer) {
                  btn.classList.add('incorrect');
                }
                btn.disabled = true;
              });

              // Update the pagination button color
              const paginationButton = document.querySelector(
                `.pagination-button:nth-child(${parseInt('{{question_index}}') + 1})`,
              );
              if (userAnswer === result.correctAnswer) {
                paginationButton.classList.add('correct');
                paginationButton.classList.remove('incorrect');
              } else {
                paginationButton.classList.add('incorrect');
                paginationButton.classList.remove('correct');
              }
            } catch (error) {
              console.error('There was a problem with the fetch operation:', error);
            }
          });
        });
      });

      let isNavigatingWithinTest = false;
      let chartIsCreated = false;

      window.addEventListener('beforeunload', async function(e) {
        if (!isNavigatingWithinTest && !{{test.is_done}} && (!{{test.is_done}} && !chartIsCreated)) {
          var confirmationMessage = 'Ви точно хочете цього? Прогрес не збережетсься';
          const leavePage = confirm(confirmationMessage);
          if (leavePage) {
            try {
              const response = await fetch(`/tests/delete/{{test.test_id}}`, {
                method: 'DELETE',
                headers: {
                  'Content-Type': 'application/json',
                },
              });

              if (!response.ok) {
                throw new Error('Network response was not ok');
              }
            } catch (error) {
              console.error('There was a problem with the fetch operation:', error);
              return;
            }
          }
          e.returnValue = confirmationMessage; // Gecko, Trident, Chrome 34+
          return confirmationMessage; // Gecko, WebKit, Chrome <34
        }
      });

      async function navigateToQuestion(testId, questionIndex) {
        isNavigatingWithinTest = true;
        window.location.href = `/tests/exam/?test_id=${testId}&question_index=${questionIndex}`;
      }

      async function endTest(testId, title, disabled, button) {
        button.disabled = false;

        try {
          const response = await fetch(`/tests/finish/${testId}`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
          });

          if (!response.ok) {
            throw new Error('Network response was not ok');
          }

          const result = await response.json();
          document.getElementById('answeredQuestions').textContent = `${result.answeredQuestions}/${result.answeredQuestions+result.unansweredQuestions}`;
          document.getElementById('resultsTitle').textContent = title;

          if(!chartIsCreated) {
            renderDoughnutChart(result.correctAnswers, result.incorrectAnswers, result.unansweredQuestions);
            chartIsCreated = true;
          }

          document.getElementById('endTestModal').style.display = 'flex';
        } catch (error) {
          console.error('There was a problem with the fetch operation:', error);
        }
      }

      function renderDoughnutChart(correctAnswers, incorrectAnswers, unansweredQuestions) {
        const totalQuestions = correctAnswers + incorrectAnswers + unansweredQuestions;
        const correctPercentage = ((correctAnswers / totalQuestions) * 100).toFixed(2);

        const data = {
          labels: ['Правильні', 'Неправильні', 'Без відповіді'],
          datasets: [{
            data: [correctAnswers, incorrectAnswers, unansweredQuestions],
            backgroundColor: ['#4CAF50', '#F44336', '#9E9E9E'],
          }],
        };


        const doughnutLabel = {
          id: 'doughnutLabel',
          afterDatasetsDraw(chart, args, pluginOptions) {
            const { ctx, data } = chart;
            ctx.save();
            console.log('dsradrs');
            const xCoor = 1000;
            const yCoor = 1000;
            ctx.font = 'bold 30px sans-serif';
            ctx.fillStyle = '#4CAF50';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(correctPercentage + '%', xCoor, yCoor);
          },
        };

        // config
        const config = {
          type: 'doughnut',
          data,
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              datalabels: {
                formatter: function(value, context) {
                  return context.chart.data.labels[context.dataIndex] + '\n' + value;
                },
                color: '#fff',
                font: {
                  weight: 'bold',
                },
              },
              tooltip: {
                callbacks: {
                  label: function(tooltipItem) {
                    return '\t\t\t\t\t\t' + tooltipItem.raw;
                  },
                },
              },
              doughnutLabel,
            },
          },
        };

        // render init block
        const ctx = new Chart(
          document.getElementById('resultChart').getContext('2d'),
          config,
        );

      }


      function closeModal() {
        document.getElementById('endTestModal').style.display = 'none';
      }

    </script>

  {{/inline}}
{{/layout}}